# 👐 $match and $project

MongoDB’s **Aggregation Framework** allows for powerful data transformations and analysis. The **$match**, **$project**, and **$sort** stages are fundamental building blocks of an aggregation pipeline.

---

## **🔹 $match → Filtering data**

Just like `.find()` based on the query mentioned, the `$match` stage filters documents from the collection.

### **Syntax**

```js
{ $match: { <query> } }
```


<InteractiveQueryEditor
  initialQuery='db.books.aggregate([{ $match: { year: { $gt: 2010 } } }])'
/>

**Syntax:**
```js
db.books.aggregate([
  {
    $match: { year: { $gt: 2010 } },
  },
]);
```

:::info
Place `$match` as early as possible in the pipeline to reduce the number of documents processed in later stages.
:::

---

## **🔹 $project → Selecting fields**

- The `$project` stage controls which fields are included in the output.
- It can also be used for adding computed fields to the results.

### **Syntax**

```js
{
  $project: {
    field1: 1,
    field2: 1,
    _id: 0
  }
}
```

- `1`: Include the field
- `0`: Exclude the field

Get all books published after 2010, showing only title, year, and page count:

<InteractiveQueryEditor
  initialQuery='db.books.aggregate([{ $match: { year: { $gt: 2010 } } }, { $project: { title: 1, year: 1, pages: 1, _id: 0 } }])'
/>

**Syntax:**
```js
db.books.aggregate([
  {
    $match: { year: { $gt: 2010 } },
  },
  {
    $project: {
      title: 1,
      year: 1,
      pages: 1,
      _id: 0,
    },
  },
]);
```

### **Equivalent SQL query**

```sql
SELECT title, year, pages FROM books WHERE year>2010;
```

### **Computed fields example:** Along with the title and authors, also output the count of authors for every book in the database.

<InteractiveQueryEditor
  initialQuery='db.books.aggregate([{ $project: { title: 1, authors: 1, authorCount: { $size: "$authors" } } }])'
/>

**MongoDB syntax:**
```js
db.books.aggregate([
  {
    $project: {
      title: 1,
      authors: 1,
      authorCount: { $size: "$authors" },
    },
  },
]);
```

---

## Challenge 🚀
<InteractiveExercise
  title="Challenge 1: Filter with $match"
  description="Find books with more than 2 available copies using aggregation."
  initialQuery='db.books.aggregate([{ $match: { available: { $gt: 2 } } }])'
  hint="Use $match stage with available field and $gt operator"
  solution='db.books.aggregate([{ $match: { available: { $gt: 2 } } }])'
/>

<InteractiveExercise
  title="Challenge 2: Combined $match and $project"
  description="Find books with more than 2 available copies. Return only book titles and publication year."
  initialQuery='db.books.aggregate([{ $match: { available: { $gt: 2 } } }, { $project: { title: 1, year: 1, _id: 0 } }])'
  hint="Use $match first, then $project to select only title and year fields"
  solution='db.books.aggregate([{ $match: { available: { $gt: 2 } } }, { $project: { title: 1, year: 1, _id: 0 } }])'
/>


<details>
  <summary>Answers</summary>

  **Challenge 1:**
  ```js
  db.books.aggregate([
    { $match: {available: {$gt: 2}}}
  ]);
  ```

  **Challenge 2:**
  ```js
  db.books.aggregate([
    { $match: {available: {$gt: 2}}},
    { $project: {title: 1, year: 1, _id: 0}}
  ]);
  ```
</details>
